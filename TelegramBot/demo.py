# -----------------------IMPORT LIBRERIAS---------------------------

from diccionarios import AVISOS_PRUEBA, PETICIONES_PRUEBA
from claves import OPENAI_API_KEY, CURAIME_BOT_KEY
from datetime import datetime
from telegram import (Update, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove, Location)
from telegram.ext import (ApplicationBuilder, MessageHandler, filters, ContextTypes, ConversationHandler)

import nest_asyncio
import openai
import json
import os
import requests
import asyncio
import time
import re

# -------------------------------------------------------------------

nest_asyncio.apply()

# Configuraci√≥n de claves
TELEGRAM_GROUP_ID = "-1002545875124"
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
os.environ["CURAIME_BOT_KEY"] = CURAIME_BOT_KEY
openai.api_key = OPENAI_API_KEY

# Etapas de conversaci√≥n
ESPERANDO_UBICACION, ESPERANDO_MEDIA = range(2)

# Mensaje de sistema para OpenAI
system_content_prompt = (
    "Eres un asistente del Ayuntamiento de Madrid encargado de clasificar reportes ciudadanos. "
    "Los reportes pueden ser de tipo 'aviso' (problemas o incidencias) o 'petici√≥n' (solicitudes de mejora). "
    "Debes analizar un mensaje del usuario e identificar su tipo ('aviso' o 'petici√≥n'), una categor√≠a y una subcategor√≠a, "
    "siguiendo estrictamente los valores que aparecen en los diccionarios oficiales del Ayuntamiento.\n\n"

    "Aqu√≠ tienes el listado completo de categor√≠as y subcategor√≠as v√°lidas:\n\n"
    f"Categor√≠as y subcategor√≠as para AVISOS:\n"
    f"{json.dumps(AVISOS_PRUEBA, indent=2, ensure_ascii=False)}\n\n"
    f"Categor√≠as y subcategor√≠as para PETICIONES:\n"
    f"{json.dumps(PETICIONES_PRUEBA, indent=2, ensure_ascii=False)}\n\n"

    "üîç IMPORTANTE:\n"
    "- Aunque el mensaje del usuario no coincida exactamente con las palabras del diccionario, intenta identificar sin√≥nimos o frases similares.\n"
    "- Si el mensaje describe una situaci√≥n que encaja con alguna subcategor√≠a, devu√©lvela aunque est√© redactada de forma diferente.\n"
    "- Si no puedes identificar claramente ninguna categor√≠a o subcategor√≠a v√°lida, no devuelvas nada.\n\n"
    
    "‚ö†Ô∏è DEVUELVE SOLO UN JSON V√ÅLIDO. EL FORMATO DEBE SER EL SIGUIENTE:\n"
    '{"tipo": "aviso", "categor√≠a": "Alumbrado P√∫blico", "subcategor√≠a": "Calle Apagada"}\n\n'
    "No incluyas ning√∫n otro texto ni explicaci√≥n, solo el JSON.\n"
)

# ------------------------FUNCIONES----------------------------------

# Env√≠a el mensaje del usuario a OpenAI para analizarlo. Si detecta que es un aviso o petici√≥n con una categor√≠a y subcategor√≠a 
# v√°lidas (seg√∫n los diccionarios que tienes), devuelve esa informaci√≥n estructurada. Si no es v√°lido, devuelve None.
async def analizar_mensaje_con_openai(mensaje_usuario: str):
    print(f"Analizando mensaje: {mensaje_usuario}")

    prompt = [
        {"role": "system", "content": system_content_prompt},
        {"role": "user", "content": mensaje_usuario}
    ]

    try:
        response = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=prompt,
            temperature=0.2
        )
        contenido = response.choices[0].message["content"]
        print(f"Respuesta de OpenAI: {contenido}")
        
        resultado = json.loads(contenido)
        
        # Verificar si el resultado corresponde con una categor√≠a y subcategor√≠a v√°lidas
        if "tipo" in resultado and "categor√≠a" in resultado and "subcategor√≠a" in resultado:
            tipo = resultado["tipo"]
            categoria = resultado["categor√≠a"]
            subcategoria = resultado["subcategor√≠a"]
            print(f"Tipo: {tipo}, Categor√≠a: {categoria}, Subcategor√≠a: {subcategoria}")

            # Verificamos si el tipo, categor√≠a y subcategor√≠a son v√°lidos
            fuente = AVISOS_PRUEBA if tipo.lower() == "aviso" else PETICIONES_PRUEBA
            if categoria in fuente:
                subcategorias = fuente[categoria]
                if isinstance(subcategorias, dict):  # Si es un diccionario de subcategor√≠as
                    if subcategoria not in subcategorias:
                        print(f"Subcategor√≠a '{subcategoria}' no v√°lida en la categor√≠a '{categoria}'.")
                        return None  # Si la subcategor√≠a no es v√°lida, devolvemos None
                elif isinstance(subcategorias, list):  # Si es una lista de subcategor√≠as
                    if not any(subcat["nombre"].lower() == subcategoria.lower() for subcat in subcategorias):
                        print(f"Subcategor√≠a '{subcategoria}' no v√°lida en la categor√≠a '{categoria}'.")
                        return None  # Si la subcategor√≠a no es v√°lida, devolvemos None
            else:
                print(f"Categor√≠a '{categoria}' no v√°lida para el tipo '{tipo}'.")
                return None  # Si la categor√≠a no es v√°lida, devolvemos None

            print("Resultado v√°lido, retornando.")
            return resultado
        else:
            print("No se encontraron 'tipo', 'categor√≠a' o 'subcategor√≠a' en la respuesta de OpenAI.")
    except Exception as e:
        print("Error al analizar respuesta de OpenAI:", e)
        print("Contenido recibido:", contenido)

    return None

# Recibe el mensaje del usuario y lo analiza con la funci√≥n anterior. Si es v√°lido, guarda la informaci√≥n en context.user_data, 
# informa al usuario del tipo de reporte detectado y le pide que comparta su ubicaci√≥n. Si no es v√°lido, le muestra un mensaje 
# explicando qu√© es un aviso o una petici√≥n.
async def manejar_mensaje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    mensaje = update.message.text
    print(f"‚ïî‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï")
    print(f"Mensaje recibido de {user_id}: {mensaje}")

    resultado = await analizar_mensaje_con_openai(mensaje)

    if not resultado or "tipo" not in resultado or "categor√≠a" not in resultado or "subcategor√≠a" not in resultado:
        print("Mensaje no clasificado correctamente. Respondiendo con mensaje gen√©rico.")
        print(f"‚ïö‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï")
        await update.message.reply_text(
            "üëã Hola, soy el bot del Ayuntamiento de Madrid.\n\n"
            "Estoy aqu√≠ para ayudarte a comunicar *avisos* y *peticiones*:\n\n"
            "üî¥ *Aviso*: Cuando quieras informar de un problema, da√±o o incidencia en tu barrio (por ejemplo: una farola rota, ruido molesto, suciedad en la calle...).\n\n"
            "üü¢ *Petici√≥n*: Cuando desees proponer una mejora o solicitar algo nuevo (por ejemplo: m√°s bancos en un parque, nueva zona deportiva, m√°s papeleras...).\n\n"
            "‚úçÔ∏è Por favor, escribe tu mensaje explicando el problema o la mejora que necesitas. Yo me encargo de clasificarlo y enviarlo al Ayuntamiento.",
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    tipo = resultado["tipo"]
    categoria = resultado["categor√≠a"]
    subcategoria = resultado["subcategor√≠a"]
    print(f"Clasificado como: Tipo='{tipo}', Categor√≠a='{categoria}', Subcategor√≠a='{subcategoria}'")

    # Buscar el ID de subcategor√≠a
    id_subcategoria = None
    fuente = AVISOS_PRUEBA if tipo.lower() == "aviso" else PETICIONES_PRUEBA

    # Verificamos que la categor√≠a est√© bien definida en el diccionario
    if categoria in fuente:
        subcategorias = fuente[categoria]
        if isinstance(subcategorias, dict):  # Si es un diccionario de subcategor√≠as
            for subcat_key, subcat_data in subcategorias.items():
                if subcat_key.lower() == subcategoria.lower() or subcat_data["nombre"].lower() == subcategoria.lower():
                    id_subcategoria = subcat_data["id"][0] if subcat_data["id"] else None
                    break
        elif isinstance(subcategorias, list):  # Si es una lista de subcategor√≠as
            for subcat_data in subcategorias:
                if subcat_data["nombre"].lower() == subcategoria.lower():
                    id_subcategoria = subcat_data["id"][0] if subcat_data["id"] else None
                    break
    else:
        print(f"Categor√≠a '{categoria}' no encontrada en el diccionario.")

    context.user_data["reporte"] = {
        "tipo": tipo,
        "categoria": categoria,
        "subcategoria": subcategoria,
        "id_subcategoria": id_subcategoria,
        "descripcion": mensaje
    }

    boton_ubicacion = ReplyKeyboardMarkup(
        [[KeyboardButton("üìç Enviar ubicaci√≥n", request_location=True)]],
        one_time_keyboard=True,
        resize_keyboard=True
    )

    print("Esperando ubicaci√≥n del usuario...")

    await update.message.reply_text(
        f"‚úÖ He detectado un {tipo} en la categor√≠a '{categoria}' y subcategor√≠a '{subcategoria}'.\n\n"
        "Por favor, env√≠ame la ubicaci√≥n del incidente:",
        reply_markup=boton_ubicacion
    )
    return ESPERANDO_UBICACION

# Toma la ubicaci√≥n enviada por el usuario, completa los datos del reporte (incluyendo nombre, fecha y coordenadas) y los env√≠a a 
# un grupo de Telegram formateados como mensaje. Luego confirma al usuario que el reporte ha sido enviado correctamente.
async def recibir_ubicacion(update: Update, context: ContextTypes.DEFAULT_TYPE):
    ubicacion: Location = update.message.location
    datos = context.user_data.get("reporte", {})

    if not datos:
        print("Error: No tengo datos del reporte. Finalizando conversaci√≥n.")
        await update.message.reply_text("‚ùå No tengo datos del reporte. Int√©ntalo de nuevo.", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END
    print(f"Ubicaci√≥n recibida: Latitud {ubicacion.latitude}, Longitud {ubicacion.longitude}")

    datos["latitud"] = ubicacion.latitude
    datos["longitud"] = ubicacion.longitude
    datos["usuario"] = update.message.from_user.full_name
    datos["fecha"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    await update.message.reply_text(
        "üì∏ Si quieres, ahora puedes enviar una *foto o video* del problema. "
        "Esto puede ayudar a los equipos del Ayuntamiento.\n\n"
        "O pulsa 'Omitir' para continuar sin archivo.",
        reply_markup=ReplyKeyboardMarkup([["Omitir"]], one_time_keyboard=True, resize_keyboard=True),
        parse_mode="Markdown"
    )

    return ESPERANDO_MEDIA

# Env√≠a el mensaje del usuario al grupo de Telegram con la informaci√≥n del reporte. Si el usuario env√≠a una foto o video, lo adjunta al mensaje.
# Si el usuario decide omitir el archivo, env√≠a el mensaje sin multimedia. Luego confirma al usuario que el reporte ha sido enviado.
# Finalmente, finaliza la conversaci√≥n.
async def recibir_media(update: Update, context: ContextTypes.DEFAULT_TYPE):
    datos = context.user_data.get("reporte", {})

    if not datos:
        await update.message.reply_text("‚ùå No tengo datos del reporte. Int√©ntalo de nuevo.", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END

    archivo = None
    tipo_media = None

    if update.message.photo:
        archivo = update.message.photo[-1].file_id  # √∫ltima = mayor resoluci√≥n
        tipo_media = "foto"
    elif update.message.video:
        archivo = update.message.video.file_id
        tipo_media = "video"
    elif update.message.text and update.message.text.lower() == "omitir":
        tipo_media = "omitido"
    else:
        await update.message.reply_text("‚ùå Por favor, env√≠a una foto, un video o pulsa 'Omitir'.")
        return ESPERANDO_MEDIA

    mensaje_grupo = (
        f"üì¢ Nuevo {datos['tipo'].upper()} recibido:\n\n"
        f"üë§ Usuario: {datos['usuario']}\n"
        f"üóì Fecha: {datos['fecha']}\n"
        f"üìÑ Descripci√≥n: {datos['descripcion']}\n"
        f"üìå Tipo: {datos['tipo']}\n"
        f"üìÇ Categor√≠a: {datos['categoria']}\n"
        f"üîñ Subcategor√≠a: {datos['subcategoria']}\n"
        f"üîñ ID Subcategoria: `{datos['id_subcategoria']}`\n"
        f"üìç Ubicaci√≥n: https://maps.google.com/?q={datos['latitud']},{datos['longitud']}"
    )

    print(f"‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï")
    print("üì¢ Nuevo", datos['tipo'].upper(), "recibido:\n")
    print("üë§ Usuario:", datos['usuario'])
    print("üìÜ Fecha:", datos['fecha'])
    print("üìÑ Descripci√≥n:", datos['descripcion'])
    print("üìå Tipo:", datos['tipo'])
    print("üìÇ Categor√≠a:", datos['categoria'])
    print("üîñ Subcategor√≠a:", datos['subcategoria'])
    print("üîñ ID Subcategor√≠a:", datos['id_subcategoria'])
    print("üìç Ubicaci√≥n: https://maps.google.com/?q=" + str(datos['latitud']) + "," + str(datos['longitud']))
    print(f"‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï")

    print("Enviando mensaje al grupo con" + (" multimedia" if tipo_media != "omitido" else " sin multimedia"))
    print(f"‚ïö‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï")

    if tipo_media == "foto":
        await context.bot.send_photo(chat_id=TELEGRAM_GROUP_ID, photo=archivo, caption=mensaje_grupo, parse_mode="Markdown")
    elif tipo_media == "video":
        await context.bot.send_video(chat_id=TELEGRAM_GROUP_ID, video=archivo, caption=mensaje_grupo, parse_mode="Markdown")
    else:
        await context.bot.send_message(chat_id=TELEGRAM_GROUP_ID, text=mensaje_grupo, parse_mode="Markdown")

    await update.message.reply_text(
        "‚úÖ Tu reporte ha sido enviado al Ayuntamiento. ¬°Gracias por tu colaboraci√≥n!",
        reply_markup=ReplyKeyboardRemove()
    )

    return ConversationHandler.END

# -------------------------MAIN---------------------------------------

# Inicia el bot y configura el manejador de conversaci√≥n para recibir mensajes y ubicaciones.
# Cuando el usuario env√≠a un mensaje, se analiza y se le pide la ubicaci√≥n. Luego, se le pide que env√≠e una foto o video del problema.
# Finalmente, se env√≠a el reporte al grupo de Telegram y se confirma al usuario que su reporte ha sido enviado.

if __name__ == '__main__':
    app = ApplicationBuilder().token(CURAIME_BOT_KEY).build()

    conversation_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.TEXT & ~filters.COMMAND, manejar_mensaje)],
        states={
            ESPERANDO_UBICACION: [MessageHandler(filters.LOCATION, recibir_ubicacion)],
            ESPERANDO_MEDIA: [
                MessageHandler(filters.PHOTO | filters.VIDEO | filters.TEXT, recibir_media)
            ]
        },
        fallbacks=[],
    )

    app.add_handler(conversation_handler)

    print("ü§ñ Bot en funcionamiento...")
    app.run_polling()
    print("üö´ Bot detenido.")